=Ocsigen from A to Z=

This page describes the main concept you need to master to become fully operational
with Ocsigen.

It is highly recommended to generate your first Ocsigen Start app to see
running examples of all these concepts while reading this page.

<<section |
<<header |==OCaml==>>

This programming guide assumes you know the //OCaml// language.
Many resources and books are available online.

>>

<<section |
<<header |==Lwt==>>

//Lwt// is a concurrent programming library for OCaml, initially written
by Jérôme Vouillon in 2001 for the
[[https://github.com/bcpierce00/unison|Unison]] file synchronizer.
It provides an alternative to the more usual preemptive threads approach
for programming concurrent applications, that avoids most problems of concurrent
data access and deadlocks.
It is used by Ocsigen Server and Eliom and has now become one of the
standard ways to implement concurrent applications in OCaml.
All your Web sites must be written in Lwt-compatible way!

<<concept title="How it works"|
Instead of calling blocking functions, like {{{ Unix.sleep }}}
or {{{ Unix.read }}}, that could block the entire program, replace them
by their cooperatives counterparts ({{{ Lwt_unix.sleep}}},
{{{ Lwt_unix.read}}}, etc.). Instead of taking time to execute,
they always return immediately a //promise// of the result,
of type {{{'a Lwt.t}}}. This type is abstract, and the only way
to use the result is to //bind// a function to the promise.
{{{Lwt.bind p f}}} means: "when promise {{{p}}} is completed, give its result
to function {{{f}}}".

Syntax {{{let%lwt x = p in e}}} is equivalent to {{{Lwt.bind p (fun x -> e)}}}
and makes it very easy to sequentialize computations without blocking the rest
of the program.
>>

Read more about Lwt in its [[wiki("lwt"):|user manual]].

>>

<<section |
<<header |==TyXML: typing HTML==>>

<<code language="ocaml"|
open Eliom_content.Html.D
>>

<<code language="ocaml"|
(html
  (head (title (txt "")) [])
  (body [h1 ~a:[a_id "toto"; a_class ["blah"; "blih"]]
          [txt "Hallo!"]])))
>>

<<|From Eliom > 2.2
(you can also use <<a_api project="eliom" subproject="server"|val Eliom_tools.D.html>> to ease the creation of the {{{head}}} tag.)

(Eliom_tools.F.head
    ~title:"Hello"
    ~css:[["css";"style.css"]]
    ~js:[["libjs";"mylib.js"];
         ["libjs";"otherlib.js"]]
    ())
>>

<<code language="ocaml"|img
  ~alt:"blip"
  ~src:(make_uri
         (Eliom_service.static_dir ())
         ["dir" ; "image.jpg"])
  ()
>>

<<concept title="How it works"|

>>

Module {{{Eliom_content.Html.F}}} will create a functional value representing
your nodes. On client side, calling {{{Eliom_content.Html.To_dom.of_element}}}
on these nodes will create a new DOM node.

Module {{{Eliom_content.Html.D}}} will automatically insert an id in the
attributes of the node, to label a precise instance of the node in the DOM.
On client side, calling {{{Eliom_content.Html.To_dom.of_element}}}
on these nodes will return the actual version of the nodes that are currently
in the page.

In a client server Eliom app,
you probably always want to use {{{Eliom_content.Html.D}}}
whenever you want to bind events on
an element (and more generally if you need to inject this element using {{{~%}}}).
>>

<<section |
<<header |==Eliom: Services==>>

Page are generated by //services//.

To create a service, call <<a_api project="eliom"| val Eliom_service.create>>.
For example, the following code defines a service at URL {{{/foo}}},
that will use GET HTTP method, and take one parameter of type string,
named {{{"myparam"}}}.
<<code language="ocaml" class="server"|
let myservice =
  Eliom_service.create
    ~path:(Eliom_service.Path ["foo"])
    ~meth:(Eliom_service.Get (Eliom_parameter.string "myparam"))
    ()
>>

Then register an OCaml function as handler on this service:

===Outputs===

<<div id="servicetable"|
|=@@class="row"@@<<a_api project="eliom" text="Html5"| module Eliom_registration.Html5 >>|@@colspan="3"@@Typed HTML5 pages|
|=@@class="row"@@<<a_api project="eliom" text="App"| module Eliom_registration.ELIOM_APPL >>|@@colspan="3"@@HTML5 pages belonging to an Eliom client/server application (functor)|
|=@@class="row"@@<<a_api project="eliom" text="Flow5"| module Eliom_registration.Flow5 >>|@@colspan="3"@@Portions of HTML5 pages.|
|=@@class="row"@@<<a_api project="eliom" text="Action"| module Eliom_registration.Action >>|@@colspan="3"@@Actions (server side effects) with or without reloading the page|
|=@@class="row"@@<<a_api project="eliom" text="Files"| module Eliom_registration.File >>|@@colspan="3"@@Files|
|=@@class="row"@@<<a_api project="eliom" text="Ocaml"| module Eliom_registration.Ocaml >>|@@colspan="3"@@OCaml value to be sent to a client side OCaml program|
|=@@class="row"@@<<a_api project="eliom" text="String"| module Eliom_registration.String >>|@@colspan="3"@@Any OCaml string (array of byte)|
|=@@class="row"@@<<a_api project="eliom" text="Redirection"| module Eliom_registration.Redirection >>|@@colspan="3"@@Redirection to another service|
|=@@class="row"@@<<a_api project="eliom" text="Any"| module Eliom_registration.Any >>|@@colspan="3"@@To be used to make the service chose what it sends|
|=@@class="row"@@<<a_api project="eliom" text="Customize"| module Eliom_registration.Customize >>|@@colspan="3"@@Defining your own registration module (functor)|
>>

===Parameters===

Module <<a_api project="eliom"| module Eliom_parameter>>
is used to describe the type of service parameters.

Examples:
<<code language="ocaml"|
Eliom_parameter.(int "i" ** (string "s" ** bool "b"))
   (* /path?i=42&s=toto&b=on *)

Eliom_parameter.(int "i" ** opt (string "s"))
   (* An integer named i, and an optional string named s *)

Eliom_parameter.(int "i" ** any)
   (* An integer named i, and any other parameters, as an association list
      of type (string * string) list *)

Eliom_parameter.(set string "s")
   (* /path?s=toto&s=titi&s=bobo *)

Eliom_parameter.(list "l" (int "i"))
   (* /path?l[0]=11&l[1]=2&l[2]=42 *)

Eliom_parameter.(suffix (int "year" ** int "month"))
   (* /path/2012/09 *)

>>

===POST services===

===Other types of services===


===Predefined services===
<<a_api project="eliom"| val Eliom_service.external_service >> to create links of form towards external Web sites

<<a_api project="eliom"| val Eliom_service.static_dir >> to create links towards static files.
<<a_api project="eliom"| val Eliom_service.void_coservice' >> to create links or forms towards the current URL~ ...

>>

<<section |
<<header |==Forms and links==>>

Functions {{{Eliom_content.Html.F.a}}} and {{{D.a}}}
create typed links to services with their parameters.
For example, if {{{home_service}}} expects no parameter
and {{{other_service}}} expects a string:
<<code language="ocaml"|
Eliom_content.Html.D.a ~service:home_service [txt "Home"] ()
Eliom_content.Html.D.a ~service:other_service [txt "Other"] "hello"
>>

Modules {{{Eliom_content.Html.F.Raw}}} and {{{D.Raw}}} define the links
and form elements with the usual typed interface from TyXML.
Use this for example if you want to manipulate the form contents
from client side functions.

Modules {{{Eliom_content.Html.F}}} and {{{D}}} define a typed interface
for form elements. Use this for links (see above), or if you program traditional
server-side Web interaction to check that your form correspond to the
service. Example:

<<code language="ocaml"|
open Eliom_content.Html.D
>>

<<code language="ocaml"|
post_form
 ~service:connection_service
   (fun (name, password) ->
     [fieldset
       [label ~a:[a_for name] [txt "Name: "];
        string_input ~input_type:`Text ~name:name ();
        br ();
        string_input
          ~a:[a_placeholder "Password"]
          ~input_type:`Password
          ~name:password
          ();
        br ();
        string_input ~input_type:`Submit ~value:"Connect" ()
      ]]) ()

>>

>>
<<section |
<<header |==Js_of_ocaml==>>

//Js_of_ocaml// is a compiler of OCaml bytecode to JavaScript,
allowing to run Ocaml programs in a Web browser.
Its key features are the following:
* The whole language, and most of the standard library are supported.
* The compiler is easy to install: it depends only on Findlib and Lwt.
* The generated code which is independant of Eliom and the Ocsigen Server. You can use it with any Web server.
* You can use a standard installation of OCaml to compile your programs. In particular, you do not have to recompile a library to use it with Js_of_ocaml. You just have to link your program with a specific library to interface with the browser API.


|{{{obj##m : u}}}|when {{{obj : <m : u prop> Js.t}}}|
|{{{obj##m <- e : unit}}}|when {{{obj : <m : u prop> Js.t}}} and {{{e:u}}}|
|{{{obj##m(e_1, ..., e_n) : u}}}|when {{{obj : <m : t_1 -> ... -> t_n -> u meth; ..> Js.t}}} and {{{e_i : t_i}}}|
|{{{jsnew constr (e1, ..., en) : u}}}|when {{{constr : (t_1 -> ... -> t_n -> u Js.t) Js.constr}}} and {{{e_i : t_i}}}|

>>

<<section |
<<header |==Eliom: client-server apps==>>

Eliom transforms OCaml into a multi-tier language, allowing one to
implement (both the server and client parts of) a distributed application
entirely in OCaml, as a single program.
This simplifies the communication between server and client.

Page can be generated either on the server or the client.
The first HTTP request usually returns a server-side generated HTML page
(thus indexable by seach engine). But subsequent page generations are done
by the client, for performance reasons.
In a mobile app, all pages usually are generated on the client.

Client side features can be mixed with traditional Web interaction
(links, forms, bookmarks, back button ...)
One of the key feature of Eliom is that it allows
one to mix commonplace Web interactions (URLs, forms, links,
bookmarks, back button) with dynamic client side features. In
particular, the client-side program **does not stop** when the user
clicks a link, sends a form, or presses the back button--yet the user
still can save bookmarks on pages!  This opens up a wide field of new
possibilities, and should facilitate the emergence of new kinds of Web
applications.

===Sections===
|{{{ let%shared ... = ... }}}|Code to be included in both the client and server apps|
|{{{ let%client ... = ... }}}|Code to be included in client app only|
|{{{ let%server ... = ... }}}|Code to be included in server app only|

Same for {{{ module%shared }}}, {{{ open%shared }}}, {{{ type%shared }}} etc.

===Client values===
Client values can be declared within server or shared code as
   {{{ [%client[ (<value> : <type>) ] }}}.
The type annotation is almost always required.

If this section is reached while generating a page on server side,
the client-side code will be executed once the page is displayed.
If this section is reached while generating a page on client side,
the client-side code will be executed immediately.

[[tutowidgets|This tutorial]] shows how client values can be manipulated
on client side.

===Injections===

Server side variables can be accessed (injected) in client code by prefixing
them with {{{~%}}} as in this example:
<<code language="ocaml"|
let%server ... =
  ... let x = ... in [%client[ ... ~%x ... ]] ...
}}
>>
The value will automatically be sent with the page by Eliom.

===Example===
This section shows a typical example of client-server code.

<<code language="ocaml" class="client"|
open%client Js_of_ocaml
open%client Js_of_ocaml_lwt
open%client Eliom_content.Html>>
<<code language="ocaml" class="shared"|open%shared Eliom_content.Html.F>>
<<code language="ocaml" class="server"|let%server g () = Lwt.return (string_of_int (10000 + Random.int 1000))>>
<<code language="ocaml"|

let%shared () =
  Bs_base.App.register ~service:Bs_services.toto (fun s () ->
      let aa = string_of_int (Random.int 1000) in
      let _ = [%client (print_endline ~%aa : unit)] in
      let b = Eliom_content.Html.D.button [txt aa] in
      let _ =
        [%client
          (Lwt.async (fun () ->
               Lwt_js_events.clicks (To_dom.of_element ~%b) (fun _ _ ->
                   Dom_html.window##alert (Js.string (~%aa));
                   Lwt.return_unit))
            : unit)]
      in
      Lwt.return (html (head (title (txt s)) []) (body [h1 [txt s]; b])))
>>

>>


<<section |
<<header |==Sessions==>>

Session data is saved in //Eliom references//.
<<code language="ocaml"|
let count_ref =
  Eliom_reference.eref ~scope:Eliom_common.session 0
>>

<<code language="ocaml"|
lwt count = Eliom_reference.get count_ref in
Eliom_reference.set count_ref (count + 1)
>>

You can choose a reference to be persistant (value saved on hard drive) or volatile (in memory).

===Scopes===
Sessions are relative to a browser, and implemented using browser cookies.
But Eliom allows to create Eliom references with other //scopes// than session:

|<<a_api project="eliom" text="global_scope"| val Eliom_common.global_scope>>|Global value for all the app|
|<<a_api project="eliom" text="default_group_scope"| val Eliom_common.default_group_scope>>|Value for a group of sessions. For example Ocsigen Start defines a group of session for each user, making it possible to save server side data for all sessions of a user.|
|<<a_api project="eliom" text="default_session_scope"| val Eliom_common.default_session_scope>>|The usual session data, based on browser cookies|
|<<a_api project="eliom" text="default_process_scope"| val Eliom_common.default_process_scope>>|Server side data for a given client-side process (a tab of the browser or a mobile app).|

Applications based on Ocsigen Start use these scopes for user management.
Session or client process data are discarded when a user logs in or out.
But Ocsigen Start also defines scopes
<<a_api project="ocsigen-start" | val Os_session.user_indep_session_scope>>
and
<<a_api project="ocsigen-start" | val Os_session.user_indep_process_scope>>
which remain even if user logs in or out.
>>

<<section |
<<header |==Browser events==>>

Attributes like {{{a_onclick}}} in module {{{Eliom_content.Html.D}}} or {{{F}}}
take a client side function as parameter:

<<code language="ocaml" class="shared"|
div ~a:[a_onclick [%client fun ev -> ... ]] [ ... ]
>>

Module {{{Lwt_js_events}}} of Js_of_ocaml defines a way to bind browser events
using Lwt promises.

For example,
the following code will wait for a click on element {{{d}}} before continuing:
<<code language="ocaml" class="client"|
let%lwt ev = Lwt_js_events.click (Eliom_content.Html.To_dom.of_element ~%d) in
...
>>

Functions like {{{Lwt_js_events.clicks}}} or {{{Lwt_js_events.mousedowns}}}
will call the function given as second parameter
for each {{{click}}} or {{{mousedown}}} events
on their first parameter.

For example, the following code (extracted from [[graffiti|this tutorial]])
will wait for all {{{mousedown}}} events on the canvas,
then for each {{{mousemove}}} event on the document,
it will call function {{{f}}}, until {{{mouseup}}} is triggered.
(See <<a_api project="lwt"| val Lwt.pick>>)
<<code language="ocaml" class="client"|
let open Lwt_js_events in
Lwt.async (mousedowns
            (Eliom_content.Html.To_dom.of_element ~%canvas)
            (fun ev _ ->
               Lwt.pick [mousemoves Dom_html.document f;
	                 mouseup Dom_html.document]))
>>
>>

<<section |
<<header |==Ocsigen Toolkit==>>

>>

<<section |
<<header |==Ocsigen Start==>>

//Ocsigen-start// is a library and a template of Eliom application,
with many common features like
user registration, login box, notification system, etc.

>>

<<section |
<<header |==Database access==>>

>>

<<section |
<<header |==Server to client communication==>>

Modules
<<a_api project="eliom"| module Eliom_notif>>
and
<<a_api project="ocsigen-start"| module Os_notif>>
define the simplest interface to enable server to client communication
(the second one being aware of Ocsigen Start users).

<<concept title="How it works"|
Say you want to receive the messages for one or more chat rooms.
First, define your notification module:
<<code language="ocaml" class="server"|
module%server Notif = Os_notif.Make_Simple (struct
  type key = int64 (* the chat room ids *)
  type notification = string (* the type of messages *)
end)
>>

If you want to be notified when there a new message in a chat room, call function
{{{Notif.listen}}} (server side) on the chat room id.

If you want to send a message in a chat room, call function
{{{Notif.notify}}} (server side) with the chat room id and the message as parameter.

On client side, {{{~%(Notif.client_ev ())}}} is a React event of type
{{{(key, notif) React.E.t}}}. Use it to receive the messages.
>>

Eliom has other communication modules:
* <<a_api project="eliom"| module Eliom_bus>> defines a communication bus,
that you can use to share information with other client processes
(see an example [[application|here]]).
* <<a_api project="eliom"| module Eliom_react>> defines client-server React events.
* <<a_api project="eliom"| module Eliom_comet>> is lower level interface for
server to client communication.

>>

<<section |
<<header |==Reactive programming==>>

Eliom also provides reactive pages (generated on server or client), an
advanced session mechanism, facilities for server to client
communication, support for continuation-based Web programming, etc.

>>

<<section |
<<header |==Mobile apps==>>
Applications can run on any Web browser or mobile device (iOS, Android, ...),
thus eliminating the need for one custom version per platform.
>>

<<section |
<<header |==Ocsigen Server==>>

//Ocsigen Server// is a full featured Web server written in modular way.
It implements most features of the HTTP protocol, and has a powerful
extension mechanism that make easy to plug your own OCaml modules
for generating pages. Many extensions are already written:
;<<a_manual project="ocsigenserver" chapter="staticmod"|Staticmod>>
:    to serve static files.
;[[wiki("eliom"):|Eliom]]
:    to create reliable client/server Web applications
     or Web sites in OCaml using advanced high level concepts.
;<<a_manual project="ocsigenserver" chapter="extendconfiguration"|Extendconfiguration>>
:    allows for more options in the configuration file.
;<<a_manual project="ocsigenserver" chapter="accesscontrol"|Accesscontrol>>
:    allows to restrict the access to the sites from the config file (to request coming from a subnet, containing some headers, etc.).
;<<a_manual project="ocsigenserver" chapter="authbasic"|Authbasic>>
:    allows to restrict the access to the sites from the config file using Basic HTTP Authentication.
;<<a_manual project="ocsigenserver" chapter="cgimod"|CGImod>>
:    serves CGI scripts. It may also be used to serve PHP through CGI.
;<<a_manual project="ocsigenserver" chapter="deflatemod"|Deflatemod>>
:    used to compress data before sending to the client.
;<<a_manual project="ocsigenserver" chapter="redirectmod"|Redirectmod>>
:    sets redirections towards other Web sites from the configuration file.
;<<a_manual project="ocsigenserver" chapter="revproxy"|Revproxy>>
:    a reverse proxy for Ocsigen Server.
      It allows to ask another server to handle the request.
;<<a_manual project="ocsigenserver" chapter="rewritemod"|Rewritemod>>
:    changes in incoming requests before sending them to other extensions.
;<<a_manual project="ocsigenserver" chapter="outputfilter"|Outputfilter>>
:    rewrites some parts of the output before sending it to the client.
;<<a_manual project="ocsigenserver" chapter="userconf"|Userconf>>
:    allows users to have their own configuration files.
;<<a_manual project="ocsigenserver" chapter="comet"|Comet>>
:    facilitates server to client communications.

Ocsigen Server has a <<a_manual project="ocsigenserver"
chapter="config"|sophisticated configuration>> file mechanism allowing
complex configurations of sites.

>>
